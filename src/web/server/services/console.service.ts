/**
 * Console service
 * Manages terminal sessions in single-user mode (shared globally)
 * Wraps VibeTunnel functionality with cc-devtools authentication
 */

import * as logger from '../utils/logger.js';

import type {
  ConsoleSession,
  CreateSessionRequest,
  SessionListResponse,
  ConsoleSessionValidationResult,
  SessionCwdResponse,
  VibeDeleteResponse,
  VibeSessionCreationResponse,
} from '../../shared/types/console.js';

interface SessionMetadata {
  id: string;
  userId: string;
  name: string;
  autoGenerated: boolean;
  createdAt: Date;
  workingDir: string;
  activityStatus?: {
    isActive: boolean;
    specificStatus?: {
      app: string;
      status: string;
    };
  };
}

/**
 * In-memory session registry
 * Maps sessionId -> SessionMetadata
 */
const sessionRegistry = new Map<string, SessionMetadata>();

/**
 * Extract directory name from full path
 * Example: /Users/shaen/projects/cc-devtools -> cc-devtools
 */
function getDirectoryName(path: string): string {
  const normalized = path.replace(/^~/, '');
  const segments = normalized.split('/').filter(Boolean);
  return segments[segments.length - 1] ?? path;
}

/**
 * Generate auto name with duplicate numbering and Claude status
 * Strategy: Dynamic numbering (1-A), hide (1) for first instance (2-A)
 * Include Claude status when available (e.g., "cc-devtools - Claude: Thinking")
 */
function generateAutoName(
  userId: string,
  cwd: string,
  excludeSessionId?: string,
  activityStatus?: {
    isActive: boolean;
    specificStatus?: {
      app: string;
      status: string;
    };
  }
): string {
  const baseName = getDirectoryName(cwd);

  // Find all auto-generated sessions for this user with the same base directory name
  const duplicates: string[] = [];

  for (const [sessionId, metadata] of sessionRegistry.entries()) {
    if (
      sessionId !== excludeSessionId &&
      metadata.userId === userId &&
      metadata.autoGenerated &&
      getDirectoryName(metadata.workingDir) === baseName
    ) {
      duplicates.push(sessionId);
    }
  }

  // Build base name with numbering if needed
  let name: string;
  if (duplicates.length === 0) {
    name = baseName;
  } else {
    // Return base name with (N) where N = total count (existing duplicates + 1)
    name = `${baseName} (${duplicates.length + 1})`;
  }

  // Append Claude status if available
  if (activityStatus?.specificStatus?.app === 'claude') {
    name = `${name} - Claude: ${activityStatus.specificStatus.status}`;
  }

  return name;
}

/**
 * Renumber all auto-generated sessions with duplicate directory names for a user
 * Called after session deletion or CWD change to maintain dynamic numbering
 * Preserves Claude status in session names
 */
function renumberDuplicates(userId: string): void {
  // Group sessions by base directory name
  const groupsByDir = new Map<string, string[]>();

  for (const [sessionId, metadata] of sessionRegistry.entries()) {
    if (metadata.userId === userId && metadata.autoGenerated) {
      const baseName = getDirectoryName(metadata.workingDir);
      const group = groupsByDir.get(baseName) ?? [];
      group.push(sessionId);
      groupsByDir.set(baseName, group);
    }
  }

  // Renumber each group
  for (const [baseName, sessionIds] of groupsByDir.entries()) {
    if (sessionIds.length === 1) {
      // Only one session with this directory - remove numbering
      const metadata = sessionRegistry.get(sessionIds[0]);
      if (metadata) {
        let name = baseName;
        // Append Claude status if available
        if (metadata.activityStatus?.specificStatus?.app === 'claude') {
          name = `${name} - Claude: ${metadata.activityStatus.specificStatus.status}`;
        }
        metadata.name = name;
      }
    } else {
      // Multiple sessions - add numbering starting from 2 (first one has no number)
      sessionIds.forEach((sessionId, index) => {
        const metadata = sessionRegistry.get(sessionId);
        if (metadata) {
          let name = index === 0 ? baseName : `${baseName} (${index + 1})`;
          // Append Claude status if available
          if (metadata.activityStatus?.specificStatus?.app === 'claude') {
            name = `${name} - Claude: ${metadata.activityStatus.specificStatus.status}`;
          }
          metadata.name = name;
        }
      });
    }
  }
}

/**
 * VibeTunnel API client
 * Makes HTTP calls to VibeTunnel endpoints mounted at root (/)
 */
class VibeAPIClient {
  private baseUrl: string;

  constructor(baseUrl = 'http://localhost:3000') {
    this.baseUrl = baseUrl;
  }

  async createSession(workingDir?: string, cols?: number, rows?: number): Promise<{ sessionId: string }> {
    // VibeTunnel API requires command array and cwd (not workingDir)
    const url = `${this.baseUrl}/sessions`;
    const payload = {
      command: [process.env.SHELL ?? 'bash'],
      cwd: workingDir,
      cols: cols ?? 120,
      rows: rows ?? 30,
    };

    logger.debug(`Creating VibeTunnel session: POST ${url}`, payload);

    const response = await fetch(url, {
      method: 'POST',
      // @inline-type-allowed - HTTP header types are well-known and don't need abstraction
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload),
    });

    if (!response.ok) {
      logger.error(`VibeTunnel session creation failed: ${response.status} ${response.statusText}`);
      throw new Error(`Failed to create VibeTunnel session: ${response.statusText}`);
    }

    const data = await response.json() as VibeSessionCreationResponse;
    logger.info(`VibeTunnel session created: ${data.sessionId}`);
    return { sessionId: data.sessionId };
  }

  async listSessions(): Promise<Array<{ id: string }>> {
    const response = await fetch(`${this.baseUrl}/sessions`);

    if (!response.ok) {
      throw new Error(`Failed to list VibeTunnel sessions: ${response.statusText}`);
    }

    return response.json() as Promise<Array<{ id: string }>>;
  }

  async getSession(sessionId: string): Promise<{
    id: string;
    cwd?: string;
    activityStatus?: {
      isActive: boolean;
      specificStatus?: {
        app: string;
        status: string;
      };
    };
  } | null> {
    const response = await fetch(`${this.baseUrl}/sessions/${sessionId}`);

    if (response.status === 404) {
      return null;
    }

    if (!response.ok) {
      throw new Error(`Failed to get VibeTunnel session: ${response.statusText}`);
    }

    return response.json() as Promise<{
      id: string;
      cwd?: string;
      activityStatus?: {
        isActive: boolean;
        specificStatus?: {
          app: string;
          status: string;
        };
      };
    }>;
  }

  async deleteSession(sessionId: string): Promise<boolean> {
    const response = await fetch(`${this.baseUrl}/sessions/${sessionId}`, {
      method: 'DELETE',
    });

    if (response.status === 404) {
      return false;
    }

    if (!response.ok) {
      throw new Error(`Failed to delete VibeTunnel session: ${response.statusText}`);
    }

    const data = await response.json() as VibeDeleteResponse;
    return data.success;
  }
}

let vibeClient = new VibeAPIClient();

/**
 * Configure the VibeTunnel client with the correct server port
 * Must be called after server starts and port is known
 */
export function configureVibeClient(port: number): void {
  // VibeTunnel mounted at root, so routes are at /api/sessions, /api/auth, etc.
  vibeClient = new VibeAPIClient(`http://localhost:${port}/api`);
  logger.debug(`Configured VibeTunnel client for port ${port}`);
}

/**
 * Console Service
 */

/**
 * Create a new terminal session for a user
 */
export async function createSession(
  userId: string,
  request: CreateSessionRequest
): Promise<ConsoleSession> {
  const workingDir = request.initialDirectory ?? process.cwd();

  try {
    // Create session in VibeTunnel
    const vibeSession = await vibeClient.createSession(workingDir);

    // Generate auto name based on directory
    const autoName = generateAutoName(userId, workingDir);

    // Register session with user ownership
    const metadata: SessionMetadata = {
      id: vibeSession.sessionId,
      userId,
      name: request.name ?? autoName,
      autoGenerated: !request.name, // If user provided name, it's not auto-generated
      createdAt: new Date(),
      workingDir,
      activityStatus: undefined, // Will be populated by getSessionCwd polling
    };

    sessionRegistry.set(vibeSession.sessionId, metadata);

    logger.debug(`Created console session ${vibeSession.sessionId} for user ${userId} with name "${metadata.name}" (auto: ${metadata.autoGenerated})`);

    return toConsoleSession(metadata);
  } catch (error) {
    logger.error('Failed to create console session:', error);
    throw new Error('Failed to create terminal session');
  }
}

/**
 * List all sessions for a user
 */
export async function listSessions(userId: string): Promise<SessionListResponse> {
  const userSessions: ConsoleSession[] = [];

  for (const [sessionId, metadata] of sessionRegistry.entries()) {
    if (metadata.userId === userId) {
      try {
        // Validate session still exists in VibeTunnel
        const vibeSession = await vibeClient.getSession(sessionId);

        if (vibeSession) {
          userSessions.push(toConsoleSession(metadata));
        } else {
          // Session is dead, remove from registry
          sessionRegistry.delete(sessionId);
          logger.debug(`Removed dead session ${sessionId} from registry`);
        }
      } catch (error) {
        logger.error(`Failed to validate session ${sessionId}:`, error);
        // Keep session in registry, don't fail the whole list operation
      }
    }
  }

  return { sessions: userSessions };
}

/**
 * Validate a session belongs to a user and still exists
 */
export async function validateSession(
  userId: string,
  sessionId: string
): Promise<ConsoleSessionValidationResult> {
  const metadata = sessionRegistry.get(sessionId);

  if (!metadata || metadata.userId !== userId) {
    return { valid: false };
  }

  try {
    const vibeSession = await vibeClient.getSession(sessionId);

    if (!vibeSession) {
      // Session is dead, remove from registry
      sessionRegistry.delete(sessionId);
      return { valid: false };
    }

    return {
      valid: true,
      session: toConsoleSession(metadata),
    };
  } catch (error) {
    logger.error(`Failed to validate session ${sessionId}:`, error);
    return { valid: false };
  }
}

/**
 * Destroy a session
 */
export async function destroySession(userId: string, sessionId: string): Promise<boolean> {
  const metadata = sessionRegistry.get(sessionId);

  if (!metadata || metadata.userId !== userId) {
    return false;
  }

  try {
    const success = await vibeClient.deleteSession(sessionId);

    if (success) {
      sessionRegistry.delete(sessionId);
      logger.debug(`Destroyed console session ${sessionId}`);

      // Renumber remaining sessions with duplicate directory names
      renumberDuplicates(userId);
    }

    return success;
  } catch (error) {
    logger.error(`Failed to destroy session ${sessionId}:`, error);
    throw new Error('Failed to destroy terminal session');
  }
}

/**
 * Get current working directory for a session
 * Also updates session name with Claude status when available
 */
export async function getSessionCwd(
  userId: string,
  sessionId: string
): Promise<SessionCwdResponse | null> {
  const metadata = sessionRegistry.get(sessionId);

  if (!metadata || metadata.userId !== userId) {
    return null;
  }

  try {
    const vibeSession = await vibeClient.getSession(sessionId);

    if (!vibeSession) {
      return null;
    }

    const currentCwd = vibeSession.cwd ?? metadata.workingDir;
    const currentActivity = vibeSession.activityStatus;

    // Debug logging
    if (currentActivity?.specificStatus) {
      logger.debug(
        `Session ${sessionId} activity: ${currentActivity.specificStatus.app} - ${currentActivity.specificStatus.status}`
      );
    }

    // Update activity status in metadata
    const activityChanged =
      JSON.stringify(metadata.activityStatus) !== JSON.stringify(currentActivity);
    if (activityChanged) {
      metadata.activityStatus = currentActivity;
      logger.debug(`Session ${sessionId} activity status changed`);
    }

    // Check if we need to update the name
    const cwdChanged = metadata.autoGenerated && currentCwd !== metadata.workingDir;

    // If CWD changed or activity status changed (for auto-generated sessions), update the name
    if (metadata.autoGenerated && (cwdChanged || activityChanged)) {
      const oldWorkingDir = metadata.workingDir;
      metadata.workingDir = currentCwd;

      // Generate new auto name (excluding this session from duplicate check)
      const newName = generateAutoName(userId, currentCwd, sessionId, currentActivity);
      metadata.name = newName;

      if (cwdChanged) {
        logger.debug(
          `Auto-updated session ${sessionId} name to "${newName}" (CWD changed from ${oldWorkingDir} to ${currentCwd})`
        );
      } else {
        logger.debug(
          `Auto-updated session ${sessionId} name to "${newName}" (activity status changed)`
        );
      }

      // Renumber all sessions to handle any new duplicates or removed duplicates
      renumberDuplicates(userId);
    }

    return {
      sessionId,
      cwd: currentCwd,
      name: metadata.name, // Return updated name so frontend can update immediately
    };
  } catch (error) {
    logger.error(`Failed to get cwd for session ${sessionId}:`, error);
    return null;
  }
}

/**
 * Update session name
 * If name is empty string, reset to auto-generated mode
 * Otherwise, set manual name and disable auto-generation
 */
export function updateSessionName(
  userId: string,
  sessionId: string,
  name: string
): boolean {
  const metadata = sessionRegistry.get(sessionId);

  if (!metadata || metadata.userId !== userId) {
    return false;
  }

  // Empty string = reset to auto-generated
  if (name.trim() === '') {
    metadata.autoGenerated = true;
    metadata.name = generateAutoName(userId, metadata.workingDir, sessionId, metadata.activityStatus);
    logger.debug(`Reset session ${sessionId} to auto-generated name: "${metadata.name}"`);

    // Renumber all sessions to handle new auto-generated session
    renumberDuplicates(userId);
  } else {
    // Set manual name and disable auto-generation
    metadata.autoGenerated = false;
    metadata.name = name;
    logger.debug(`Set manual name for session ${sessionId} to "${name}"`);

    // Renumber all sessions (removing this one from auto-numbering)
    renumberDuplicates(userId);
  }

  return true;
}

/**
 * Convert internal SessionMetadata to ConsoleSession
 */
function toConsoleSession(metadata: SessionMetadata): ConsoleSession {
  return {
    id: metadata.id,
    name: metadata.name,
    autoGenerated: metadata.autoGenerated,
    currentDirectory: metadata.workingDir,
    createdAt: metadata.createdAt.toISOString(),
    status: 'running',
    pid: undefined,
  };
}
