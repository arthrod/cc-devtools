import { useState, useEffect, useRef } from 'react';
import { useOutletContext } from 'react-router-dom';
import { ConsoleHeader } from '../components/console/ConsoleHeader';
import { ConsoleTabs } from '../components/console/ConsoleTabs';
import { ConsoleContent } from '../components/console/ConsoleContent';
import { SessionSelectModal } from '../components/console/SessionSelectModal';
import { useIsMobile } from '../hooks/useIsMobile';
import type { ConsoleTab, ConsoleSession } from '../../shared/types/console';
import {
  useConsoleSessions,
  useUpdateSessionName,
  useDestroySession,
} from '../hooks/useConsoleSessions';
import {
  loadTabsFromStorage,
  saveTabsToStorage,
  watchTabsInOtherTabs,
} from '../utils/consolePersistence';

interface AppLayoutContext {
  setConsoleMenuState: (state: {
    tabs: ConsoleTab[];
    activeTabId: string | null;
    onNewTab: () => void;
    onSelectTab: (id: string) => void;
    onCloseTab: (id: string) => void;
  } | null) => void;
}

/**
 * Console page with tabbed terminal interface.
 *
 * Manages multiple terminal sessions as tabs with the following features:
 * - Create new sessions via + button
 * - Switch between active tabs
 * - Close individual tabs
 * - Rename tabs by double-clicking
 * - Persist tabs across page refreshes using hybrid localStorage + server validation
 * - Auto-save tab state with debouncing
 * - Sync tabs across multiple browser tabs/devices via storage events (single-user mode)
 */
export function ConsolePage(): JSX.Element {
  const [tabs, setTabs] = useState<ConsoleTab[]>([]);
  const [activeTabId, setActiveTabId] = useState<string | null>(null);
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [isInitialized, setIsInitialized] = useState(false);

  // Fetch sessions from server for validation
  const { data: sessionsData } = useConsoleSessions();

  // Mutation hooks for server actions
  const updateSessionName = useUpdateSessionName();
  const destroySession = useDestroySession();

  // Debounce timer for auto-save
  const saveTimerRef = useRef<NodeJS.Timeout | null>(null);

  const handleNewTab = (): void => {
    setIsModalOpen(true);
  };

  const handleSessionSelected = (session: ConsoleSession): void => {
    // Generate unique tab ID
    const tabId = `tab-${Date.now()}-${Math.random().toString(36).slice(2, 9)}`;

    // Create new tab
    const newTab: ConsoleTab = {
      id: tabId,
      sessionId: session.id,
      name: session.name,
      autoGenerated: session.autoGenerated,
    };

    // Add tab and set as active
    setTabs((prevTabs) => [...prevTabs, newTab]);
    setActiveTabId(tabId);
  };

  const handleSelectTab = (tabId: string): void => {
    setActiveTabId(tabId);
  };

  const handleCloseTab = (tabId: string): void => {
    setTabs((prevTabs) => {
      const newTabs = prevTabs.filter((tab) => tab.id !== tabId);

      // If we closed the active tab, select another one
      if (tabId === activeTabId) {
        if (newTabs.length > 0) {
          // Select the previous tab if exists, otherwise the first tab
          const closedIndex = prevTabs.findIndex((tab) => tab.id === tabId);
          const newActiveIndex = Math.max(0, closedIndex - 1);
          setActiveTabId(newTabs[newActiveIndex]?.id ?? null);
        } else {
          setActiveTabId(null);
        }
      }

      return newTabs;
    });
  };

  const handleRenameTab = (tabId: string, newName: string): void => {
    const tab = tabs.find((t) => t.id === tabId);
    if (!tab) return;

    // Call server API to update session name
    updateSessionName.mutate({ sessionId: tab.sessionId, name: newName });

    // Optimistically update local state (server will sync back via polling)
    setTabs((prevTabs) =>
      prevTabs.map((t) =>
        t.id === tabId
          ? {
              ...t,
              name: newName.trim() === '' ? t.name : newName,
              autoGenerated: newName.trim() === '',
            }
          : t
      )
    );
  };

  const handleCloseSession = (sessionId: string): void => {
    // Call server API to destroy session
    destroySession.mutate(sessionId);

    // Optimistically remove all tabs with this sessionId
    setTabs((prevTabs) => {
      const newTabs = prevTabs.filter((t) => t.sessionId !== sessionId);

      // If we closed the active tab's session, select another tab
      if (prevTabs.some((t) => t.sessionId === sessionId && t.id === activeTabId)) {
        if (newTabs.length > 0) {
          setActiveTabId(newTabs[0]?.id ?? null);
        } else {
          setActiveTabId(null);
        }
      }

      return newTabs;
    });
  };

  // Effect 1: Hybrid session validation on mount
  // Load tabs from localStorage, validate with server, cleanup dead sessions
  useEffect(() => {
    if (!sessionsData || isInitialized) {
      return;
    }

    // Load tabs from localStorage
    const savedTabs = loadTabsFromStorage();

    if (savedTabs.length === 0) {
      setIsInitialized(true);
      return;
    }

    // Validate each tab's session against server
    const validSessionIds = new Set(sessionsData.map((s) => s.id));
    const validTabs = savedTabs.filter((tab) => {
      const isValid = validSessionIds.has(tab.sessionId);
      if (!isValid) {
        console.log(`[ConsolePage] Removing dead session from tabs: ${tab.sessionId}`);
      }
      return isValid;
    });

    // Update state with validated tabs
    setTabs(validTabs);

    // Set active tab (first tab if current active doesn't exist)
    if (validTabs.length > 0) {
      const savedActiveTab = validTabs.find((tab) => tab.id === activeTabId);
      if (!savedActiveTab) {
        setActiveTabId(validTabs[0]?.id ?? null);
      }
    }

    setIsInitialized(true);
  }, [sessionsData, isInitialized, activeTabId]);

  // Effect 2: Auto-save tabs to localStorage with debouncing
  useEffect(() => {
    if (!isInitialized) {
      return;
    }

    // Clear previous timer
    if (saveTimerRef.current) {
      clearTimeout(saveTimerRef.current);
    }

    // Debounce save by 500ms
    saveTimerRef.current = setTimeout(() => {
      saveTabsToStorage(tabs);
    }, 500);

    // Cleanup on unmount
    return () => {
      if (saveTimerRef.current) {
        clearTimeout(saveTimerRef.current);
      }
    };
  }, [tabs, isInitialized]);

  // Effect 3: Watch for storage changes in other browser tabs/devices
  useEffect(() => {
    const cleanup = watchTabsInOtherTabs((updatedTabs) => {
      console.log('[ConsolePage] Tabs updated in another browser tab/device, syncing...');
      setTabs(updatedTabs);

      // Adjust active tab if needed
      if (updatedTabs.length > 0) {
        const activeExists = updatedTabs.some((tab) => tab.id === activeTabId);
        if (!activeExists) {
          setActiveTabId(updatedTabs[0]?.id ?? null);
        }
      } else {
        setActiveTabId(null);
      }
    });

    return cleanup;
  }, [activeTabId]);

  // Effect 4: Sync tab names from server sessions (auto-generated names update)
  useEffect(() => {
    if (!sessionsData || !isInitialized) {
      return;
    }

    setTabs((prevTabs) =>
      prevTabs.map((tab) => {
        const session = sessionsData.find((s) => s.id === tab.sessionId);
        if (session && (session.name !== tab.name || session.autoGenerated !== tab.autoGenerated)) {
          console.log(`[ConsolePage] Syncing tab ${tab.id} name from "${tab.name}" to "${session.name}"`);
          return {
            ...tab,
            name: session.name,
            autoGenerated: session.autoGenerated,
          };
        }
        return tab;
      })
    );
  }, [sessionsData, isInitialized]);

  const activeTab = tabs.find((tab) => tab.id === activeTabId);
  const isMobile = useIsMobile();
  const context = useOutletContext<AppLayoutContext>();

  // Pass console menu state to AppLayout for mobile header dropdown
  useEffect(() => {
    if (isMobile && context?.setConsoleMenuState) {
      context.setConsoleMenuState({
        tabs,
        activeTabId,
        onNewTab: handleNewTab,
        onSelectTab: handleSelectTab,
        onCloseTab: handleCloseTab,
      });

      return () => {
        context.setConsoleMenuState(null);
      };
    }
  }, [isMobile, tabs, activeTabId, context]);

  return (
    <div className="h-full overflow-hidden flex flex-col">
      {/* Hide console header and tabs on mobile - they're in the app header dropdown */}
      <div className="hidden lg:block flex-shrink-0">
        <ConsoleHeader onNewTab={handleNewTab} />
      </div>
      <div className="hidden lg:block flex-shrink-0">
        <ConsoleTabs
          tabs={tabs}
          activeTabId={activeTabId}
          onSelectTab={handleSelectTab}
          onCloseTab={handleCloseTab}
          onRenameTab={handleRenameTab}
          onCloseSession={handleCloseSession}
        />
      </div>
      <div className="flex-1 min-h-0">
        <ConsoleContent sessionId={activeTab?.sessionId ?? null} />
      </div>

      <SessionSelectModal
        isOpen={isModalOpen}
        onClose={() => setIsModalOpen(false)}
        onSessionSelected={handleSessionSelected}
      />
    </div>
  );
}
